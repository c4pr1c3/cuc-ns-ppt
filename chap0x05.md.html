<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="黄玮">
  <title>网络安全</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="lib/reveal.js/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>


    <!-- For syntax highlighting using highlight.js-->
    <link rel="stylesheet" href="lib/reveal.js/lib/css/zenburn.css">

  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="lib/reveal.js/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
<link rel="stylesheet" media="print" href="lib/reveal.js/css/print/pdf.css" />
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'lib/reveal.js/css/print/pdf.css' : 'lib/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="lib/reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">网络安全</h1>
  <p class="author">黄玮</p>
</section>

<section>
<section id="第五章-网络扫描" class="title-slide slide level1">
<h1>第五章 网络扫描</h1>

</section>
<section id="温故" class="slide level2">
<h2>温故</h2>
<ul>
<li>访问控制是（操作）系统安全的基础</li>
<li>局域网的安全管理是网络安全的 <strong>基础</strong>
<ul>
<li>任何网络层加密数据在一个 <strong>不安全</strong> 的局域网中都有可能被嗅探</li>
<li>攻击者一旦渗透进入内部网络，后果不堪设想</li>
<li>内网安全先从管好ARP协议开始</li>
</ul></li>
<li>网络监听是 <strong>被动</strong> 分析网络安全的重要手段</li>
</ul>
</section>
<section id="知新" class="slide level2">
<h2>知新</h2>
<ul>
<li>网络扫描是主动分析网络安全的重要手段
<ul>
<li>对于黑客来说
<ul>
<li>网络扫描是网络入侵的序曲</li>
<li>网络扫描是信息收集的手段之一</li>
</ul></li>
</ul></li>
<li>对于网络管理员来说
<ul>
<li>网络扫描是网络安全防御的自我检测手段</li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="网络扫描与信息收集" class="title-slide slide level1">
<h1>网络扫描与信息收集</h1>

</section>
<section id="信息收集" class="slide level2">
<h2>信息收集</h2>
<ul>
<li>知己知彼，百战不殆</li>
</ul>
<blockquote>
<p>语出《孙子·谋攻》</p>
</blockquote>
<blockquote>
<p>知己知彼，百战不殆；不知彼而知己，一胜一负；不知彼，不知己，每战必殆。</p>
</blockquote>
</section>
<section id="信息收集的目标对象" class="slide level2">
<h2>信息收集的目标对象</h2>
<ul>
<li>目标主机</li>
<li>目标网络</li>
<li>目标应用/服务</li>
<li>目标人</li>
</ul>
</section>
<section id="信息收集之网络扫描" class="slide level2">
<h2>信息收集之网络扫描</h2>
<ul>
<li>网络扫描是实现信息收集目的 <strong>手段之一</strong></li>
<li>重点关注
<ul>
<li>目标主机</li>
<li>网络拓扑</li>
<li>目标应用/服务</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="目标主机">目标主机</h3>
<ul>
<li>在线状态
<ul>
<li>端口开放情况</li>
<li>网络服务详细信息</li>
</ul></li>
<li>外网边界入口主机</li>
<li>内网目标主机</li>
</ul>
</section>
<section class="slide level2">

<h3 id="网络拓扑">网络拓扑</h3>
<ul>
<li>网络边界：网关</li>
<li>子网划分 / VLAN / Windows 域控服务器</li>
<li>网络基础设施：DNS、DHCP、NTP、Captive Portal、Radius Server、LDAP</li>
<li>网络安全基础设施：防火墙、入侵检测、入侵防护、蜜罐和蜜网等</li>
</ul>
</section>
<section class="slide level2">

<h3 id="目标应用服务">目标应用/服务</h3>
<ul>
<li>版本信息</li>
<li>是否存在漏洞</li>
</ul>
</section>
<section id="followup-1" class="slide level2">
<h2>信息收集之踩点</h2>
<ul>
<li>直接访问
<ul>
<li>目标主机</li>
<li>目标网络</li>
<li>目标应用/服务</li>
</ul></li>
<li>黑盒测试
<ul>
<li>使用特定客户端连接指定端口/应用/服务
<ul>
<li>浏览器 / FTP /telnet</li>
</ul></li>
<li>使用特定帐号和口令尝试登录</li>
<li>模仿交互</li>
</ul></li>
</ul>
</section>
<section id="followup-2" class="slide level2">
<h2>信息收集之踩点</h2>
<ul>
<li>白盒分析
<ul>
<li>通过 banner 抓取和应用指纹识别确定了开源组件信息之后</li>
</ul></li>
</ul>
</section>
<section id="信息收集之社会工程学" class="slide level2">
<h2>信息收集之社会工程学</h2>
<ul>
<li>目标人
<ul>
<li>社交网络应用信息：微博 / SNS / blog …</li>
</ul></li>
<li>Google Hacking
<ul>
<li>site: / filetype: / inurl:</li>
<li>GHDB: Google Hacking Database</li>
</ul></li>
<li>钓鱼
<ul>
<li>电子邮件 / 即时通信 / 电话 …</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="一张图片中隐藏的信息">一张图片中隐藏的信息</h3>
<p><img data-src="images/chap0x05/photo-exif-0.png" /></p>
</section>
<section class="slide level2">

<h3 id="一张图片中隐藏的信息-1">一张图片中隐藏的信息</h3>
<p><img data-src="images/chap0x05/photo-exif-1.png" /></p>
</section>
<section class="slide level2">

<h3 id="一张图片中隐藏的信息-2">一张图片中隐藏的信息</h3>
<p><img data-src="images/chap0x05/photo-exif-2.png" /></p>
</section>
<section class="slide level2">

<h3 id="一张图片中隐藏的信息-3">一张图片中隐藏的信息</h3>
<p><a href="http://tech.sina.com.cn/digi/dc/2012-12-05/13487859580.shtml"><img data-src="images/chap0x05/mcafee-leader-gps-leakage.png" /></a></p>
</section>
<section id="intel-auto-collect-1" class="slide level2">
<h2>信息收集的自动化</h2>
<p><img data-src="images/chap0x05/maltego-1.png" /></p>
</section>
<section id="intel-auto-collect-2" class="slide level2">
<h2>信息收集的自动化</h2>
<p><img data-src="images/chap0x05/maltego-2.png" /></p>
</section>
<section id="intel-auto-collect-3" class="slide level2">
<h2>信息收集的自动化</h2>
<p><img data-src="images/chap0x05/maltego-3.png" /></p>
</section>
</section>
<section>
<section id="网络扫描原理" class="title-slide slide level1">
<h1>网络扫描原理</h1>

</section>
<section class="slide level2">

<ul>
<li>网络扫描的基本思想</li>
<li>网络扫描的基本原理</li>
<li>网络扫描的主要实现技术</li>
</ul>
</section>
<section id="基本思想" class="slide level2">
<h2>基本思想</h2>
<p><img data-src="images/chap0x05/scan-seq.png" /></p>
</section>
<section class="slide level2">

<h3 id="报文发送与接收">报文发送与接收</h3>
<p><a href="https://asciinema.org/a/pPklHDfK5vUquhbcMF70oOqbs"><img data-src="https://asciinema.org/a/pPklHDfK5vUquhbcMF70oOqbs.svg" alt="基于 scapy 动手实践一次“手动”发送与接收报文" /></a></p>
</section>
<section class="slide level2">

<h3 id="scan-by-layers">TCP/IP 协议栈视角看网络扫描</h3>
<p><img data-src="images/chap0x05/scan-by-layers.png" /></p>
</section>
<section class="slide level2">

<h3 id="scan-by-layers-flowgraph">TCP/IP 协议栈视角看网络扫描</h3>
<p><a href="attach/chap0x05/scapy-ping.pcap"><img data-src="images/chap0x05/scapy-ping.png" /></a></p>
<blockquote>
<p>Wireshark 工具菜单里 Statistics –&gt; Flow Graph</p>
</blockquote>
</section>
<section class="slide level2">

<h3 id="tcp-review">回顾：TCP 协议</h3>
<ul>
<li>Transmission Control Protocol</li>
<li>TCP是一种面向连接的，可靠的传输层协议</li>
<li>TCP建立连接过程称为三次握手</li>
</ul>
</section>
<section class="slide level2">

<p><img data-src="images/chap0x05/tcp-hdr-format.png" /></p>
</section>
<section class="slide level2">

<p><a href="https://asciinema.org/a/gs6z4NnrB1SrW13cxq67s9P8P"><img data-src="https://asciinema.org/a/gs6z4NnrB1SrW13cxq67s9P8P.svg" alt="asciicast" /></a></p>
</section>
<section class="slide level2">

<p><a href="attach/chap0x05/curl-http.pcap"><img data-src="images/chap0x05/curl-http.png" /></a></p>
</section>
<section class="slide level2">

<h3 id="udp-review">回顾：UDP 协议</h3>
<ul>
<li>User Datagram Protocol</li>
<li>UDP 是一种提供面向事务的简单不可靠信息传送服务
<ul>
<li>无连接协议：源和目的端在数据传输之前不建立连接
<ul>
<li>收发双方均无需维护连接状态信息</li>
<li>应用层按需维护连接状态信息</li>
</ul></li>
<li>尽力而为
<ul>
<li>相比较于 TCP 协议的操作系统协议栈实现而言</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<p><img data-src="images/chap0x05/udp-hdr-format.png" /></p>
</section>
<section class="slide level2">

<h3 id="icmp-review">回顾：ICMP 协议</h3>
<ul>
<li>Internet Control Message Protocol</li>
<li>用途
<ul>
<li>网关或者目标机器利用 ICMP 与源通讯</li>
<li>当出现问题时，提供反馈信息用于报告错误</li>
</ul></li>
<li>特点
<ul>
<li>其控制能力并不用于保证传输的可靠性</li>
<li>它本身也不是可靠传输的</li>
<li>并不用来反映 ICMP 报文的传输情况</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<p><img data-src="images/chap0x05/icmp-format.png" /></p>
</section>
<section id="协议标准和操作系统协议栈的关系" class="slide level2">
<h2>协议标准和（操作系统）协议栈的关系</h2>
<ul>
<li>协议标准（声明）
<ul>
<li>严格统一和规范标准
<ul>
<li>RFC 793 TRANSMISSION CONTROL PROTOCOL</li>
<li>RFC 768 User Datagram Protocol</li>
<li>RFC 791 INTERNET PROTOCOL</li>
<li>RFC 792 Internet Control Message Protocol</li>
</ul></li>
</ul></li>
<li>协议栈（实现）
<ul>
<li>严格遵循标准实现</li>
<li>标准未尽之处的实现会略有 <strong>差异</strong></li>
</ul></li>
</ul>
</section>
<section id="扫描知识库构建与规则匹配" class="slide level2">
<h2>扫描知识库构建与规则匹配</h2>
<figure>
<img data-src="images/chap0x05/scan-kb-by-layers.png" alt="" /><figcaption>每一层都可以构建独立知识库</figcaption>
</figure>
</section>
<section class="slide level2">

<h3 id="扫描知识库构建举例-iana-注册端口号">扫描知识库构建举例 —— <a href="https://tools.ietf.org/html/rfc4340#section-19.9">IANA 注册端口号</a></h3>
<ul>
<li>传输层报文头部字段特征</li>
<li>公用端口
<ul>
<li>0 到 1023</li>
</ul></li>
<li>注册端口
<ul>
<li>1024 到49151</li>
</ul></li>
<li>动态的或私有端口
<ul>
<li>49152 到 65535</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<ul>
<li><code>/etc/services</code></li>
<li><code>/usr/share/nmap/nmap-services</code> （安装 <code>nmap</code> 之后）</li>
</ul>
</section>
<section class="slide level2">

<h3 id="service-name-and-transport-protocol-port-number-registry">Service Name and Transport Protocol Port Number Registry</h3>
<p><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml"><img data-src="images/chap0x05/etc.services.png" /></a></p>
</section>
<section id="port-status" class="slide level2">
<h2>端口状态 —— 知识库构建的基础</h2>
<ul>
<li>开放 ✅
<ul>
<li>应用/服务监听该端口</li>
<li><strong>有条件有规则</strong> 地响应请求数据报文</li>
</ul></li>
<li>关闭 ⛔
<ul>
<li>无应用/服务监听该端口</li>
<li><strong>有条件有规则</strong> 地响应或忽略请求数据报文</li>
<li>操作系统会针对SYN请求报文回应RST报文</li>
</ul></li>
<li>被过滤 ⚠️
<ul>
<li>报文过滤程序监听该端口</li>
<li><strong>有条件有规则</strong> 地响应或忽略请求数据报文
<ul>
<li>报文过滤程序可能会返回报文拒绝消息</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="主机状态" class="slide level2">
<h2>主机状态</h2>
<ul>
<li>可达（在线） 📶
<ul>
<li>对至少一种类型的请求数据包有响应（充要条件）
<ul>
<li>有开放端口（充分非必要条件）</li>
</ul></li>
</ul></li>
<li>不可达（离线） 📴
<ul>
<li>对任何类型的请求数据包均无响应（充分条件）
<ul>
<li>无开放端口（必要非充分条件）
<ul>
<li>例如普通PC机，在线时但无开放端口</li>
</ul></li>
</ul></li>
<li>在线主机在防火墙的保护下也可能是不可达状态</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<p>ℹ️ 注意事项</p>
<blockquote>
<p>端口状态是传输层的概念，不要和网络层、数据链路层、物理层可达混淆</p>
</blockquote>
</section>
<section id="主机状态详细信息" class="slide level2">
<h2>主机状态详细信息</h2>
<ul>
<li>操作系统信息
<ul>
<li>发行版本、详细版本号、语言等</li>
</ul></li>
<li>端口/应用/服务状态信息
<ul>
<li>端口状态</li>
<li>应用程序版本</li>
</ul></li>
<li>远程获取主机状态详细信息的基础
<ul>
<li>主机扫描</li>
<li>TCP/IP 协议栈实现知识库
<ul>
<li>不同操作系统/应用程序的差异</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="主机扫描技术" class="title-slide slide level1">
<h1>主机扫描技术</h1>

</section>
<section id="可达状态检测" class="slide level2">
<h2>可达状态检测</h2>
<ul>
<li>局域网
<ul>
<li>ARP 扫描</li>
</ul></li>
<li>广域网
<ul>
<li>ICMP Echo 扫描</li>
<li>ICMP Sweep 扫描</li>
<li>ICMP Broadcast 扫描</li>
<li>ICMP Non-Echo 扫描</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="arping">局域网 ARP 扫描</h3>
<pre class="python"><code>#! /usr/bin/env python
# arping: arpings a network

import sys
from scapy.all import srp, Ether, ARP, conf


if len(sys.argv) != 2:
    print(&quot;Usage: arping &lt;net&gt;\n  eg: arping 192.168.56.1/24&quot;)
    sys.exit(1)

conf.verb = 0

pkt = Ether(dst=&quot;ff:ff:ff:ff:ff:ff&quot;)/ARP(pdst=sys.argv[1])
ans, unans = srp(pkt, timeout=2)

for snd, rcv in ans:
    print(&quot;{} {}&quot;.format(rcv.src, rcv.psrc))</code></pre>
</section>
<section class="slide level2">

<figure>
<img data-src="images/chap0x05/arping-flowgraph.png" alt="" /><figcaption>ARP Ping 请求响应过程示意图</figcaption>
</figure>
</section>
<section class="slide level2">

<h3 id="icmp-echo-扫描">ICMP echo 扫描</h3>
<ul>
<li>实现原理
<ul>
<li>ping的实现机制</li>
</ul></li>
<li>优点
<ul>
<li>简单，系统支持</li>
</ul></li>
<li>缺点
<ul>
<li>很容易被防火墙限制</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="icmp-sweep-扫描">ICMP Sweep 扫描</h3>
<pre class="python"><code>#!/usr/bin/env python

import sys
import threading
import ipaddress
from scapy.all import ICMP, IP, sr1
from queue import Queue

if len(sys.argv) &lt; 2:
    print(&quot;Usage: icmping &lt;host&gt; [icmp_type] [icmp_code]\n&quot;)
    print(&quot;eg: icmping 192.168.56.0/24&quot;)
    print(&quot;eg: icmping 192.168.56.0/24 13 0&quot;)
    print(&quot;eg: icmping 192.168.56.0/24 15 0&quot;)
    print(&quot;eg: icmping 192.168.56.0/24 17 0&quot;)
    sys.exit(1)

network = sys.argv[1]
if len(sys.argv) &lt; 3:
    icmp_type = 8
else:
    icmp_type = int(sys.argv[2])

if len(sys.argv) &lt; 4:
    icmp_code = 0
else:
    icmp_code = int(sys.argv[3])

max_threads = 100
ip_net = ipaddress.ip_network(network)
all_hosts = list(ip_net.hosts())
live_count = 0

print(&#39;Sweeping Network with ICMP: {} type={}/code={}&#39;.format(network, icmp_type, icmp_code))


def pingsweep(ip):
    host = str(all_hosts[ip])
    resp = sr1(
        IP(dst=str(host))/ICMP(type=icmp_type, code=icmp_code),
        timeout=2,
        verbose=0,
    )

    if resp is None:
        # print(f&quot;{host} is down or not responding.&quot;)
        return 0
    elif (
        int(resp.getlayer(ICMP).type) == 3 and int(resp.getlayer(ICMP).code) in [1, 2, 3, 9, 10, 13]
    ):
        # print(f&quot;{host} is blocking ICMP.&quot;)
        return 0
    else:
        print(f&quot;{host} is responding.&quot;)
        return 1


def threader():
    while True:
        worker = q.get()
        pingsweep(worker)
        q.task_done()


q = Queue()

for x in range(max_threads):
    t = threading.Thread(target=threader)
    t.daemon = True
    t.start()

for worker in range(len(all_hosts)):
    q.put(worker)

q.join()</code></pre>
</section>
<section class="slide level2">

<figure>
<img data-src="images/chap0x05/icmp-sweep-scan.png" alt="" /><figcaption>ICMP Sweep 扫描</figcaption>
</figure>
</section>
<section class="slide level2">

<h3 id="icmp-broadcast-扫描">ICMP Broadcast 扫描</h3>
<ul>
<li>实现原理
<ul>
<li>将ICMP请求包的目标地址设为广播地址或网络地址，则可以探测广播域或整个网络范围内的主机</li>
</ul></li>
<li>缺点
<ul>
<li>只适合于UNIX/Linux系统，Windows 会忽略这种请求包；</li>
<li>这种扫描方式容易引起广播风暴</li>
</ul></li>
</ul>
<pre class="bash"><code>ping -b 192.168.0.255</code></pre>
</section>
<section id="icmp-broadcast-扫描-1" class="slide level2">
<h2><a href="attach/chap0x05/icmp-broadcast-scan.pcap"><img data-src="images/chap0x05/icmp-broadcast-scan.png" alt="ICMP Broadcast 扫描" /></a></h2>
<h3 id="non-echo-icmp-扫描">Non-Echo ICMP 扫描</h3>
<p>一些其它 ICMP 类型包也可以用于对主机或网络设备的探测，如：</p>
<ul>
<li>Stamp Request(Type 13) / Reply(Type 14)</li>
<li>Information Request(Type 15) / Reply(Type 16)</li>
<li>Address Mask Request (Type 17) / Reply(Type 18)</li>
</ul>
</section>
<section id="reachable-test-1" class="slide level2">
<h2>可达状态检测高级技术</h2>
<p>防火墙和网络过滤设备的存在，常常导致传统的探测手段变得无效，为了突破这种限制</p>
<ul>
<li>异常的 IP 包头</li>
<li>在 IP 头中设置无效的字段值</li>
<li>错误的数据分片</li>
<li>通过超长包探测内部路由器</li>
<li>反向映射探测</li>
</ul>
</section>
<section class="slide level2">

<h3 id="异常的ip包头">异常的IP包头</h3>
<ul>
<li>向目标主机发送包头错误的 IP 包，目标主机或过滤设备可能会反馈 <code>ICMP Parameter Problem Error</code> 信息
<ul>
<li>常见的伪造错误字段为 <code>Header Length Field</code> 和 <code>IP Options Field</code></li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="在-ip-头中设置无效的字段值">在 IP 头中设置无效的字段值</h3>
<ul>
<li>向目标主机发送的IP包中填充错误的字段值，目标主机或过滤设备会反馈 <code>ICMP Destination Unreachable</code> 信息</li>
</ul>
</section>
<section class="slide level2">

<h3 id="错误的数据分片">错误的数据分片</h3>
<ul>
<li>当目标主机接收到错误的数据分片,并且在规定的时间间隔内得不到更正时，将丢弃这些错误数据包，并向发送主机反馈 <code>ICMP Fragment Reassembly Time Exceeded</code> 错误报文</li>
</ul>
</section>
<section class="slide level2">

<h3 id="通过超长包探测内部路由器">通过超长包探测内部路由器</h3>
<ul>
<li>若构造的数据包长度超过目标系统所在路由器的 <code>PMTU</code> 且设置禁止分片标志, 该路由器会反馈 <code>Fragmentation Needed and Don’t Fragment Bit was Set</code> 差错报文，从而获取目标系统的网络拓扑结构</li>
</ul>
</section>
<section class="slide level2">

<h3 id="反向映射探测">反向映射探测</h3>
<ul>
<li>用处
<ul>
<li>该技术用于探测被过滤设备和防火墙保护的网络和主机</li>
</ul></li>
<li>方法
<ul>
<li>构造可能的内部IP地址列表，并向这些地址发送数据包</li>
<li>对方路由器进行IP识别并路由</li>
<li>根据是否返回错误报文来进行探测</li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="主机状态详细信息探测技术" class="title-slide slide level1">
<h1>主机状态详细信息探测技术</h1>

</section>
<section class="slide level2">

<ul>
<li>开放扫描
<ul>
<li>会产生大量审计数据，容易被对方发现，但其可靠性高</li>
</ul></li>
<li>隐蔽扫描
<ul>
<li>能有效避免对方入侵检测系统和防火墙的检测，但这种扫描使用的数据包在通过网络时容易被丢弃从而产生错误的探测信息</li>
</ul></li>
<li>半开放扫描
<ul>
<li>隐蔽性和可靠性介于前两者之间</li>
</ul></li>
</ul>
</section>
<section id="tcp-connect-scan-1" class="slide level2">
<h2>开放扫描 —— TCP Connect 扫描</h2>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>通信方向</th>
<th>流程 1</th>
<th>流程 2</th>
<th>流程 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>C -&gt; S</td>
<td>SYN+Port(n)</td>
<td>SYN+Port(n)</td>
<td>SYN+Port(n)</td>
</tr>
<tr class="even">
<td>2</td>
<td>S -&gt; C</td>
<td>SYN/ACK</td>
<td>RST</td>
<td>无响应/其他拒绝反馈报文</td>
</tr>
<tr class="odd">
<td>3</td>
<td>C -&gt; S</td>
<td>ACK</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>C -&gt; S</td>
<td>RST</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>状态推断</td>
<td>开放 ✅</td>
<td>关闭 ⛔</td>
<td>被过滤 ⚠️</td>
</tr>
</tbody>
</table>
</section>
<section class="slide level2">

<h3 id="tcp-connect-scan-2">TCP Connect 扫描</h3>
<ul>
<li>实现原理
<ul>
<li>connect()</li>
<li>完成TCP三次握手</li>
</ul></li>
<li>优点
<ul>
<li>稳定可靠，不需要特殊的权限</li>
</ul></li>
<li>缺点
<ul>
<li>扫描方式不隐蔽，服务器日志会记录下大量密集的连接和错误记录，并容易被防火墙发现和屏蔽</li>
</ul></li>
</ul>
</section>
<section id="udp-scan-1" class="slide level2">
<h2>开放扫描 —— UDP 扫描</h2>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>通信方向</th>
<th>流程 1</th>
<th>流程 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>C -&gt; S</td>
<td>UDP+Port(n)</td>
<td>UDP+Port(n)</td>
</tr>
<tr class="even">
<td>2</td>
<td>S -&gt; C</td>
<td>UDP+port(n) 响应数据</td>
<td>无响应/其他拒绝反馈报文</td>
</tr>
<tr class="odd">
<td></td>
<td>状态推断</td>
<td>开放 ✅</td>
<td>开放 ✅ / 关闭 ⛔ / 被过滤 ⚠️</td>
</tr>
</tbody>
</table>
</section>
<section class="slide level2">

<h3 id="udp-scan-2">UDP 扫描</h3>
<ul>
<li>实现原理
<ul>
<li>向指定 UDP 端口发送数据</li>
<li>如果「语言相通」，则服务端会根据“语言内容”（UDP 上层应用协议约定）「响应数据」</li>
<li>如果「鸡同鸭讲」，则目标端口即使处于开放状态也可能会表现出「静默无响应」行为</li>
</ul></li>
</ul>
</section>
<section id="tcp-syn-scan-1" class="slide level2">
<h2>半开放扫描 —— TCP SYN 扫描</h2>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>通信方向</th>
<th>流程 1</th>
<th>流程 2</th>
<th>流程 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>C -&gt; S</td>
<td>SYN+Port(n)</td>
<td>SYN+Port(n)</td>
<td>SYN+Port(n)</td>
</tr>
<tr class="even">
<td>2</td>
<td>S -&gt; C</td>
<td>SYN/ACK</td>
<td>RST</td>
<td>无响应/其他拒绝反馈报文</td>
</tr>
<tr class="odd">
<td>3</td>
<td>C -&gt; S</td>
<td>RST</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>状态推断</td>
<td>开放 ✅</td>
<td>关闭 ⛔</td>
<td>被过滤 ⚠️</td>
</tr>
</tbody>
</table>
</section>
<section id="tcp-syn-scan-2" class="slide level2">
<h2>半开放扫描 —— TCP SYN 扫描</h2>
<ul>
<li>实现原理
<ul>
<li>仅发送 SYN 包</li>
<li>不建立完整TCP连接</li>
<li>又称为半开放/半连接扫描</li>
</ul></li>
<li>优点
<ul>
<li>隐蔽性较全连接扫描好，很多系统对这种半扫描很少记录</li>
</ul></li>
<li>缺点
<ul>
<li>需要 <strong>操作系统管理员权限</strong> 构造 SYN 报文</li>
<li>网络防护设备会有记录</li>
</ul></li>
</ul>
</section>
<section id="tcp-proxy-scan-1" class="slide level2">
<h2>半开放扫描 —— TCP 间接扫描</h2>
<figure>
<img data-src="images/chap0x05/tcp-proxy-scan.png" alt="" /><figcaption>TCP 间接扫描</figcaption>
</figure>
</section>
<section id="tcp-proxy-scan-2" class="slide level2">
<h2>半开放扫描 —— TCP 间接扫描</h2>
<ul>
<li>实现原理
<ul>
<li>伪造 <strong>第三方源 IP</strong>（<code>跳板机 IP</code>）发起 SYN 扫描</li>
</ul></li>
<li>优点
<ul>
<li>隐蔽性好</li>
</ul></li>
<li>缺点
<ul>
<li>对跳板主机的要求较高</li>
<li>广域网中受制于路由器的包过滤规则</li>
</ul></li>
</ul>
</section>
<section id="tcp-fin-scan-1" class="slide level2">
<h2>隐蔽扫描 —— TCP FIN 扫描</h2>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>通信方向</th>
<th>流程 1</th>
<th>流程 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>C -&gt; S</td>
<td>TCP FIN+Port(n)</td>
<td>TCP FIN+Port(n)</td>
</tr>
<tr class="even">
<td>2</td>
<td>S -&gt; C</td>
<td>RST</td>
<td>无响应/其他拒绝反馈报文</td>
</tr>
<tr class="odd">
<td></td>
<td>状态推断</td>
<td>关闭 ⛔</td>
<td>开放 ✅ / 关闭 ⛔ / 被过滤 ⚠️</td>
</tr>
</tbody>
</table>
</section>
<section id="tcp-fin-scan-2" class="slide level2">
<h2>隐蔽扫描 —— TCP FIN 扫描</h2>
<ul>
<li>实现原理
<ul>
<li>仅发送 FIN 包</li>
</ul></li>
<li>优点
<ul>
<li>FIN 数据包能够通过只监测 SYN 包的包过滤器</li>
<li>隐蔽性较 SYN 扫描更高</li>
</ul></li>
<li>缺点
<ul>
<li>跟 SYN 扫描类似，需要自己构造数据包，要求由 <strong>操作系统管理员</strong> 或者授权用户访问专门的系统调用</li>
</ul></li>
</ul>
</section>
<section id="tcp-xmas-scan" class="slide level2">
<h2>隐蔽扫描 —— TCP Xmas 扫描</h2>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>通信方向</th>
<th>流程 1</th>
<th>流程 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>C -&gt; S</td>
<td>TCP FIN(1),PUSH(1),URG(1)+Port(n)</td>
<td>TCP FIN(1),PUSH(1),URG(1)+Port(n)</td>
</tr>
<tr class="even">
<td>2</td>
<td>S -&gt; C</td>
<td>RST</td>
<td>无响应/其他拒绝反馈报文</td>
</tr>
<tr class="odd">
<td></td>
<td>状态推断</td>
<td>关闭 ⛔</td>
<td>开放 ✅ / 关闭 ⛔ / 被过滤 ⚠️</td>
</tr>
</tbody>
</table>
</section>
<section id="tcp-null-scan" class="slide level2">
<h2>隐蔽扫描 —— TCP Null 扫描</h2>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>通信方向</th>
<th>流程 1</th>
<th>流程 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>C -&gt; S</td>
<td>TCP FIN(0),PUSH(0),URG(0)+Port(n)</td>
<td>TCP FIN(0),PUSH(0),URG(0)+Port(n)</td>
</tr>
<tr class="even">
<td>2</td>
<td>S -&gt; C</td>
<td>RST</td>
<td>无响应/其他拒绝反馈报文</td>
</tr>
<tr class="odd">
<td></td>
<td>状态推断</td>
<td>关闭 ⛔</td>
<td>开放 ✅ / 关闭 ⛔ / 被过滤 ⚠️</td>
</tr>
</tbody>
</table>
</section>
<section id="tcp-hidden-scan" class="slide level2">
<h2>隐蔽扫描 —— TCP Xmas 和 Null 扫描</h2>
<ul>
<li>实现原理
<ul>
<li>Xmas: 设置 TCP 报文头 FIN、URG 和 PUSH 标记</li>
<li>Null：关闭所有 TCP 报文头标记</li>
</ul></li>
<li>优点
<ul>
<li>隐蔽性好</li>
</ul></li>
<li>缺点
<ul>
<li>需要自己构造数据包，要求有 <strong>操作系统管理员</strong> 或者授权用户权限</li>
</ul></li>
</ul>
</section>
<section id="隐蔽扫描分段扫描" class="slide level2">
<h2>隐蔽扫描——分段扫描</h2>
<ul>
<li>实现原理
<ul>
<li>将一个完整 TCP 报文分割封装到 2 个或多个 IP 报文分别独立发送</li>
</ul></li>
<li>优点
<ul>
<li>隐蔽性好，可穿越防火墙</li>
</ul></li>
<li>缺点
<ul>
<li>可能被丢弃</li>
<li>某些程序在处理这些小数据包时会出现异常</li>
</ul></li>
</ul>
</section>
<section id="tcp-ack-scan-1" class="slide level2">
<h2>隐蔽扫描 —— ACK 扫描</h2>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>通信方向</th>
<th>流程 1</th>
<th>流程 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>C -&gt; S</td>
<td>ACK+Port(n)</td>
<td>ACK+Port(n)</td>
</tr>
<tr class="even">
<td>2</td>
<td>S -&gt; C</td>
<td>RST / 其他拒绝反馈报文</td>
<td>无响应</td>
</tr>
<tr class="odd">
<td></td>
<td>状态推断</td>
<td>被过滤 ⚠️</td>
<td>关闭 ⛔</td>
</tr>
</tbody>
</table>
</section>
<section id="tcp-ack-scan-2" class="slide level2">
<h2>隐蔽扫描 —— ACK 扫描</h2>
<ul>
<li>实现原理
<ul>
<li>构造并发送 ACK 报文</li>
<li>包过滤防火墙会检查 TCP 会话状态列表，若发现无匹配会话则有可能返回 RST 报文</li>
<li>正常主机的关闭端口则不会响应该报文</li>
</ul></li>
<li>优点
<ul>
<li>探测目标主机的包过滤规则</li>
</ul></li>
<li>缺点
<ul>
<li>可能被丢弃</li>
<li>不能用于判断端口是否开放</li>
</ul></li>
</ul>
</section>
<section id="tcp-idle-scan-1" class="slide level2">
<h2>隐蔽扫描 —— IDLE 扫描</h2>
<ul>
<li>跳板主机处于网络空闲状态</li>
<li>跳板主机的IP序列号产生规则是连续递增</li>
<li>广域网上的路由器必须允许伪造源IP地址</li>
</ul>
<figure>
<img data-src="images/chap0x05/tcp-idle-scan.png" alt="" /><figcaption>TCP Idle 扫描</figcaption>
</figure>
</section>
<section id="tcp-idle-scan-2" class="slide level2">
<h2>隐蔽扫描 —— IDLE 扫描</h2>
<ul>
<li>实现原理
<ul>
<li>如前图所示</li>
</ul></li>
<li>优点
<ul>
<li>相比较于 TCP 间接扫描，无需监听跳板主机的通信流量</li>
<li>目标主机很难发现真正的扫描源，扫描隐蔽性高</li>
</ul></li>
<li>缺点
<ul>
<li>对跳板主机的要求较多</li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="os-detection-techniques-1" class="title-slide slide level1">
<h1>栈指纹 OS 识别技术</h1>

</section>
<section class="slide level2">

<ul>
<li>实现原理
<ul>
<li>根据各个操作系统在 TCP/IP 协议栈实现上的不同特点</li>
<li>采用黑盒测试方法</li>
<li>研究其对各种探测的响应形成识别指纹进行识别</li>
</ul></li>
<li>根据采集指纹信息的方式，分为
<ul>
<li>被动扫描方式</li>
<li>主动扫描方式</li>
</ul></li>
</ul>
</section>
<section id="被动扫描" class="slide level2">
<h2>被动扫描</h2>
<ul>
<li>实现原理
<ul>
<li>通过网络嗅探工具收集数据包，再对数据包的不同特征（TCP Window-size、IP TTL、IP TOS、DF位等参数）进行分析，来识别操作系统</li>
</ul></li>
<li>优点
<ul>
<li>隐蔽性好</li>
</ul></li>
<li>缺点
<ul>
<li>速度慢</li>
<li>可靠性不高</li>
</ul></li>
</ul>
</section>
<section id="主动扫描" class="slide level2">
<h2>主动扫描</h2>
<ul>
<li>实现原理
<ul>
<li>采用向目标系统发送构造的特殊包并监控其应答的方式来识别操作系统的类型</li>
</ul></li>
<li>优点
<ul>
<li>速度快，可靠性高</li>
</ul></li>
<li>缺点
<ul>
<li>严重依赖目标系统网络拓扑结构和过滤规则</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="windows-os-fingerprint">Windows 指纹示例</h3>
<p><img data-src="images/chap0x05/windows-os-fingerprint.png" /></p>
</section>
<section class="slide level2">

<ul>
<li>Windows 主机的 ping 程序实现特征
<ul>
<li>TTL</li>
<li>payload
<ul>
<li>Data</li>
<li>Length</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="linux-os-fingerprint">Linux 指纹示例</h3>
<p><img data-src="images/chap0x05/linux-os-fingerprint.png" /></p>
</section>
<section class="slide level2">

<ul>
<li>Linux 主机的 ping 程序实现特征
<ul>
<li>TTL</li>
<li>payload
<ul>
<li>Data</li>
<li>Length</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<figure>
<img data-src="images/chap0x05/ping-detect-os.png" alt="" /><figcaption>仅仅通过 ping 即可粗略的判定目标操作系统类型</figcaption>
</figure>
</section>
<section id="os-detection-techniques-2" class="slide level2">
<h2>栈指纹 OS 识别的其他技术</h2>
<ul>
<li>FIN 探测
<ul>
<li>发送一个 FIN 包给一个开放端口，一般的行为是不响应，但某些实现例如 MS Windows, BSDI, CISCO, HP/UX, MVS, IRIX 等会 响应一个 RST 报文</li>
</ul></li>
<li>BOGUS 标记探测
<ul>
<li>设置一个未定义的 TCP 标记（64或128）在 SYN 包的 TCP 头里</li>
</ul></li>
<li>不分段位
<ul>
<li>许多操作系统开始在送出的一些包中设置IP的 <code>Don't Fragment</code> 位</li>
</ul></li>
</ul>
</section>
<section id="os-detection-techniques-3" class="slide level2">
<h2>栈指纹 OS 识别的其他技术</h2>
<ul>
<li>ACK 值
<ul>
<li>不同实现中一些情况下 ACK 域的值是不同的</li>
</ul></li>
<li>ICMP 错误信息终结
<ul>
<li>一些操作系统跟从限制各种错误信息的发送率</li>
</ul></li>
<li>SYN 洪水限度
<ul>
<li>如果收到过多的伪造 SYN 数据包，一些操作系统会停止新的连接尝试</li>
<li>某些操作系统默认只处理 8 个伪造的 SYN 包</li>
</ul></li>
</ul>
</section>
<section id="小结扫描知识库构建与规则匹配" class="slide level2">
<h2>小结：扫描知识库构建与规则匹配</h2>
<ul>
<li>在扫描实践中总结知识库构建
<ul>
<li>TCP/IP协议栈的每一层</li>
<li>报文的发送和接收均有规律可循，有规则可总结</li>
<li>黑盒模糊测试思想</li>
</ul></li>
<li>规则匹配
<ul>
<li>不仅仅是字符串静态匹配</li>
<li>可以是基于行为的匹配
<ul>
<li>会话：传输层 / 应用层</li>
<li>报文交互序列</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="扫描报告生成" class="title-slide slide level1">
<h1>扫描报告生成</h1>

</section>
<section class="slide level2">

<ul>
<li>数据的可视化呈现技术</li>
</ul>
<blockquote>
<p>非本课程关注重点</p>
</blockquote>
</section>
</section>
<section>
<section id="扫描行为的检测与防护" class="title-slide slide level1">
<h1>扫描行为的检测与防护</h1>

</section>
<section class="slide level2">

<ul>
<li>扫描行为的检测
<ul>
<li>被动监听
<ul>
<li>利用第四章所学的知识、工具和方法</li>
</ul></li>
</ul></li>
<li>扫描行为的防护
<ul>
<li>防火墙
<ul>
<li>将在第八章介绍</li>
</ul></li>
<li>入侵检测
<ul>
<li>将在第九章介绍</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="网络扫描工具" class="title-slide slide level1">
<h1>网络扫描工具</h1>

</section>
<section class="slide level2">

<figure>
<img data-src="images/chap0x05/nmap-in-movies.png" alt="" /><figcaption>电影中的网络扫描工具</figcaption>
</figure>
</section>
<section id="nmap" class="slide level2">
<h2>Nmap</h2>
<ul>
<li>Nmap 简介</li>
<li>Nmap 使用方法</li>
<li>ping 扫描
<ul>
<li>端口扫描</li>
<li>隐蔽扫描</li>
<li>选项功能
<ul>
<li>操作系统识别</li>
<li>防火墙/IDS躲避和哄骗</li>
</ul></li>
</ul></li>
<li>Nmap 常见应用</li>
</ul>
</section>
<section class="slide level2">

<h3 id="intro-2-nmap">Nmap 简介</h3>
<ul>
<li>Network Mapper的缩写</li>
<li>功能特性（ <strong>网络扫描的瑞士军刀</strong> ）
<ul>
<li>多种协议扫描
<ul>
<li>例如：TCP / UDP / ICMP</li>
</ul></li>
<li>支持大多数系统
<ul>
<li>例如：Linux, macOS, Microsoft Windows</li>
</ul></li>
<li>支持插件扩展
<ul>
<li>NSE: Nmap Script Engine</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="nmap-应用程序目录结构解析">Nmap 应用程序目录结构解析</h3>
<ul>
<li>可执行程序目录
<ul>
<li>/usr/bin</li>
</ul></li>
<li>文档目录
<ul>
<li>/usr/share/man</li>
<li>/usr/share/doc/nmap</li>
</ul></li>
<li>插件目录
<ul>
<li>/usr/share/nmap/nselib <strong>重点关注</strong></li>
<li>/usr/share/nmap/scripts <strong>重点关注</strong></li>
</ul></li>
<li>知识库目录
<ul>
<li>/usr/share/nmap</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<pre class="bash"><code>dpkg -L nmap
dpkg -L nmap-common</code></pre>
</section>
<section class="slide level2">

<blockquote>
<p>/usr/share/nmap</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>文件</th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>nmap-mac-prefixes</td>
<td>MAC地址对应厂家知识库</td>
</tr>
<tr class="even">
<td>nmap-os-db</td>
<td>操作系统指纹知识库</td>
</tr>
<tr class="odd">
<td>nmap-protocols</td>
<td>协议类型字段标识知识库</td>
</tr>
<tr class="even">
<td>nmap-rpc</td>
<td>RPC应用类型指纹知识库</td>
</tr>
<tr class="odd">
<td>nmap-service-probes</td>
<td>应用程序交互行为指纹知识库</td>
</tr>
<tr class="even">
<td>nmap-services</td>
<td>端口与应用/服务映射关系知识库</td>
</tr>
</tbody>
</table>
</section>
<section id="nmap-scan-flow" class="slide level2">
<h2>nmap 扫描一般流程</h2>
<p><img data-src="images/chap0x05/nmap-scan-flow.png" /></p>
</section>
<section id="howto-get-help" class="slide level2">
<h2>nmap 使用帮助</h2>
<blockquote>
<p>nmap –help</p>
</blockquote>
<blockquote>
<p>man nmap</p>
</blockquote>
</section>
<section id="howto-use-nmap" class="slide level2">
<h2>nmap 实验指南</h2>
<ul>
<li>前述扫描原理在 nmap 中的对应命令行参数组合实现</li>
<li>操作系统识别</li>
<li>防火墙/入侵检测躲避和哄骗</li>
</ul>
</section>
<section class="slide level2">

<blockquote>
<p>nmap cheatsheet</p>
</blockquote>
</section>
</section>
<section>
<section id="课后思考题" class="title-slide slide level1">
<h1>课后思考题</h1>

</section>
<section class="slide level2">

<ul>
<li>通过本章网络扫描基本原理的学习，试推测
<ul>
<li>应用程序版本信息扫描原理</li>
<li>网络漏洞扫描原理</li>
</ul></li>
<li>网络扫描知识库的构建方法有哪些？</li>
<li>除了 nmap 之外，目前还有哪些流行的网络扫描器？和 nmap 进行优缺点对比分析。</li>
</ul>
</section>
</section>
    </div>
  </div>

  <script src="lib/reveal.js/lib/js/head.min.js"></script>
  <script src="lib/reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'fade', // none/fade/slide/convex/concave/zoom
        math: {
          mathjax: '',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

menu: {
		// Specifies which side of the presentation the menu will 
		// be shown. Use 'left' or 'right'.
		side: 'left',

		// Specifies the width of the menu.
		// Can be one of the following:
		// 'normal', 'wide', 'third', 'half', 'full', or
		// any valid css length value
		width: 'normal',

		// Add slide numbers to the titles in the slide list.
		// Use 'true' or format string (same as reveal.js slide numbers)
		numbers: true,

		// Specifies which slide elements will be used for generating
		// the slide titles in the menu. The default selects the first
		// heading element found in the slide, but you can specify any
		// valid css selector and the text from the first matching
		// element will be used.
		// Note: that a section data-menu-title attribute or an element
		// with a menu-title class will take precedence over this option
		titleSelector: 'h1, h2, h3, h4, h5, h6',

		// If slides do not have a matching title, attempt to use the
		// start of the text content as the title instead
		useTextContentForMissingTitles: false,

		// Hide slides from the menu that do not have a title.
		// Set to 'true' to only list slides with titles.
		hideMissingTitles: false,

		// Adds markers to the slide titles to indicate the 
		// progress through the presentation. Set to 'false'
		// to hide the markers.
		markers: true,

		// Specify custom panels to be included in the menu, by
		// providing an array of objects with 'title', 'icon'
		// properties, and either a 'src' or 'content' property.
		custom: false,

		// Specifies the themes that will be available in the themes
		// menu panel. Set to 'true' to show the themes menu panel
		// with the default themes list. Alternatively, provide an
		// array to specify the themes to make available in the
		// themes menu panel, for example...
		// [
		//     { name: 'Black', theme: 'css/theme/black.css' },
		//     { name: 'White', theme: 'css/theme/white.css' },
		//     { name: 'League', theme: 'css/theme/league.css' }
		// ]
		themes: false,

		// Specifies the path to the default theme files. If your
		// presentation uses a different path to the standard reveal
		// layout then you need to provide this option, but only
		// when 'themes' is set to 'true'. If you provide your own 
		// list of themes or 'themes' is set to 'false' the 
		// 'themesPath' option is ignored.
		themesPath: 'css/theme/',

		// Specifies if the transitions menu panel will be shown.
		// Set to 'true' to show the transitions menu panel with
		// the default transitions list. Alternatively, provide an
		// array to specify the transitions to make available in
		// the transitions panel, for example...
		// ['None', 'Fade', 'Slide']
		transitions: false,

		// Adds a menu button to the slides to open the menu panel.
		// Set to 'false' to hide the button.
		openButton: true,

		// If 'true' allows the slide number in the presentation to
		// open the menu panel. The reveal.js slideNumber option must 
		// be displayed for this to take effect
		openSlideNumber: false,

		// If true allows the user to open and navigate the menu using
		// the keyboard. Standard keyboard interaction with reveal
		// will be disabled while the menu is open.
		keyboard: true,

		// Normally the menu will close on user actions such as
		// selecting a menu item, or clicking the presentation area.
		// If 'true', the sticky option will leave the menu open
		// until it is explicitly closed, that is, using the close
		// button or pressing the ESC or m key (when the keyboard 
		// interaction option is enabled).
		sticky: false,

		// If 'true' standard menu items will be automatically opened
		// when navigating using the keyboard. Note: this only takes 
		// effect when both the 'keyboard' and 'sticky' options are enabled.
		autoOpen: true,

		// If 'true' the menu will not be created until it is explicitly
		// requested by calling RevealMenu.init(). Note this will delay
		// the creation of all menu panels, including custom panels, and
		// the menu button.
		delayInit: false,

		// If 'true' the menu will be shown when the menu is initialised.
		openOnInit: false,

		// By default the menu will load it's own font-awesome library
		// icons. If your presentation needs to load a different
		// font-awesome library the 'loadIcons' option can be set to false
		// and the menu will not attempt to load the font-awesome library.
		loadIcons: true
	},


        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'lib/reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'lib/reveal.js/plugin/math/math.js', async: true },
          { src: 'lib/reveal.js/plugin/menu/menu.js'},
          { src: 'lib/reveal.js/plugin/markdown/marked.js'},
          { src: 'lib/reveal.js/plugin/markdown/markdown.js'},
          { src: 'lib/reveal.js/plugin/search/search.js'},
          { src: 'lib/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'lib/reveal.js/plugin/notes/notes.js', async: true },
        ]
      });
    </script>
    </body>
</html>
